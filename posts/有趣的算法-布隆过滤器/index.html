<!doctype html><html lang><meta charset=utf-8>
<meta name=viewport content="width=device-width">
<title>有趣的算法-布隆过滤器 | IO01 Blog</title>
<meta name=generator content="Hugo Eureka 0.8.0">
<link rel=stylesheet href=/css/eureka.min.css>
<script defer src=/js/eureka.min.js></script>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin>
<link rel=preload href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap" as=style onload="this.onload=null,this.rel='stylesheet'">
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/solarized-light.min.css media=print onload="this.media='all',this.onload=null" crossorigin>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/languages/dart.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js integrity="sha256-uNYoXefWRqv+PsIF/OflNmwtKM4lStn9yrz2gVl6ymo=" crossorigin></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X media=print onload="this.media='all',this.onload=null" crossorigin>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script>
<script defer src=https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js integrity="sha256-Zmpaaj+GXFsPF5WdPArSrnW3b30dovldeKsW00xBVwE=" crossorigin></script>
<link rel=icon type=image/png sizes=32x32 href=/images/favicon_huc32cac3e9dc2dba9d765d255923cde91_27863_32x32_fill_box_center_3.png>
<link rel=apple-touch-icon sizes=180x180 href=/images/favicon_huc32cac3e9dc2dba9d765d255923cde91_27863_180x180_fill_box_center_3.png>
<meta name=description content="引言
现在假设一个需求：设计一个url黑名单系统，需求是1亿个url黑名单，每个url平均长度30字节，判断当前的url是否在黑名单中。
我们最先想到的可能时HashSet，如果少量的url，HashSet有着O(1)的查询效率是首选的方案。但是面对1亿个url，单单存储value就需要2861MB内存，显然不可取。而如果放到硬盘上进行数据库查询，面对近3GB的数据库，每次匹配都要查询的话，IO操作本身就是瓶颈。
所以这时候引入了布隆过滤器。">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":2,"name":"有趣的算法-布隆过滤器","item":"/posts/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%AE%97%E6%B3%95-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%AE%97%E6%B3%95-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"},"headline":"有趣的算法-布隆过滤器 | IO01 Blog","datePublished":"2019-10-30T00:00:00+00:00","dateModified":"2019-10-30T00:00:00+00:00","wordCount":1614,"publisher":{"@type":"Person","name":"C. Wang","logo":{"@type":"ImageObject","url":"/images/favicon.png"}},"description":"\u003ch2 id=\u0022引言\u0022\u003e引言\u003c\/h2\u003e\n\u003cp\u003e现在假设一个需求：设计一个url黑名单系统，需求是1亿个url黑名单，每个url平均长度30字节，判断当前的url是否在黑名单中。\u003c\/p\u003e\n\u003cp\u003e我们最先想到的可能时HashSet，如果少量的url，HashSet有着O(1)的查询效率是首选的方案。但是面对1亿个url，单单存储value就需要2861MB内存，显然不可取。而如果放到硬盘上进行数据库查询，面对近3GB的数据库，每次匹配都要查询的话，IO操作本身就是瓶颈。\u003c\/p\u003e\n\u003cp\u003e所以这时候引入了布隆过滤器。\u003c\/p\u003e"}</script><meta property="og:title" content="有趣的算法-布隆过滤器 | IO01 Blog">
<meta property="og:type" content="article">
<meta property="og:image" content="/images/favicon.png">
<meta property="og:url" content="/posts/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%AE%97%E6%B3%95-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">
<meta property="og:description" content="引言
现在假设一个需求：设计一个url黑名单系统，需求是1亿个url黑名单，每个url平均长度30字节，判断当前的url是否在黑名单中。
我们最先想到的可能时HashSet，如果少量的url，HashSet有着O(1)的查询效率是首选的方案。但是面对1亿个url，单单存储value就需要2861MB内存，显然不可取。而如果放到硬盘上进行数据库查询，面对近3GB的数据库，每次匹配都要查询的话，IO操作本身就是瓶颈。
所以这时候引入了布隆过滤器。">
<meta property="og:site_name" content="IO01 Blog">
<meta property="article:published_time" content="2019-10-30T00:00:00+00:00">
<meta property="article:modified_time" content="2019-10-30T00:00:00+00:00">
<meta property="article:section" content="posts">
<meta property="article:tag" content="杂项">
<body class="flex flex-col min-h-screen">
<header class="fixed flex items-center w-full min-h-16 pl-scrollbar z-50 bg-secondary-bg shadow-sm">
<div class="w-full max-w-screen-xl mx-auto"><script>let storageColorScheme=localStorage.getItem("lightDarkMode");((storageColorScheme=='Auto'||storageColorScheme==null)&&window.matchMedia("(prefers-color-scheme: dark)").matches||storageColorScheme=="Dark")&&document.getElementsByTagName('html')[0].classList.add('dark')</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
<a href=/ class="mr-6 text-primary-text text-xl font-bold">IO01 Blog</a>
<button id=navbar-btn class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
<i class="fas fa-bars"></i>
</button>
<div id=target class="hidden block md:flex md:flex-grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
<div class="md:flex md:h-16 text-sm md:flex-grow pb-4 md:pb-0 border-b md:border-b-0">
</div>
<div class=flex>
<div class="relative pt-4 md:pt-0">
<div class="cursor-pointer hover:text-eureka" id=lightDarkMode>
<i class="fas fa-adjust"></i>
</div>
<div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id=is-open>
</div>
<div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40" id=lightDarkOptions>
<span class="px-4 py-1 hover:text-eureka" name=Light></span>
<span class="px-4 py-1 hover:text-eureka" name=Dark></span>
<span class="px-4 py-1 hover:text-eureka" name=Auto></span>
</div>
</div>
</div>
</div>
<div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id=is-open-mobile>
</div>
</nav>
<script>let element=document.getElementById('lightDarkMode');storageColorScheme==null||storageColorScheme=='Auto'?document.addEventListener('DOMContentLoaded',()=>{window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change',switchDarkMode)}):storageColorScheme=="Light"?(element.firstElementChild.classList.remove('fa-adjust'),element.firstElementChild.setAttribute("data-icon",'sun'),element.firstElementChild.classList.add('fa-sun')):storageColorScheme=="Dark"&&(element.firstElementChild.classList.remove('fa-adjust'),element.firstElementChild.setAttribute("data-icon",'moon'),element.firstElementChild.classList.add('fa-moon')),document.addEventListener('DOMContentLoaded',()=>{getcolorscheme(),switchBurger()})</script>
</div>
</header>
<main class="flex-grow pt-16">
<div class=pl-scrollbar>
<div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto">
<div class="grid grid-cols-2 lg:grid-cols-8 gap-4 lg:pt-12">
<div class="col-span-2 lg:col-span-6 bg-secondary-bg rounded px-6 py-8">
<h1 class="font-bold text-3xl text-primary-text">有趣的算法-布隆过滤器</h1>
<div class="flex flex-wrap flex-row items-center mt-2 text-tertiary-text">
<div class="mr-6 my-2">
<i class="fas fa-calendar mr-1"></i>
<span>2019-10-30</span>
</div>
</div>
<div class=content>
<h2 id=引言>引言</h2>
<p>现在假设一个需求：设计一个url黑名单系统，需求是1亿个url黑名单，每个url平均长度30字节，判断当前的url是否在黑名单中。</p>
<p>我们最先想到的可能时HashSet，如果少量的url，HashSet有着O(1)的查询效率是首选的方案。但是面对1亿个url，单单存储value就需要2861MB内存，显然不可取。而如果放到硬盘上进行数据库查询，面对近3GB的数据库，每次匹配都要查询的话，IO操作本身就是瓶颈。</p>
<p>所以这时候引入了布隆过滤器。</p>
<h2 id=原理>原理</h2>
<h3 id=初始化>初始化</h3>
<p>首先初始化一个长度为m的bit数组，每一位初始化为0。</p>
<h3 id=插入>插入</h3>
<p>确定k个独立的hash函数，每个hash可以将输入的url生成并映射为1个[0,m-1]的值，每个值作为数组下标，将该位置的值置为1。</p>
<h3 id=查询>查询</h3>
<p>同插入部分，将输入的url用插入时确定的k个hash函数生成k个数组下标，逐个检测每个下标对应的位置的值，如果有一个不为1则确定不在集合中，如果全部为1，则有可能在集合中。</p>
<h3 id=误判>误判</h3>
<p>误判来自两方面：</p>
<ol>
<li>由于hash函数是有碰撞几率的，虽然多个hash会大大降低这种几率，但是仍然有几率两个完全不同的url通过hash后得到的k个值完全相同。</li>
<li>多次插入以后不同的插入组合可能与某个未插入值经过hash后的值相同，我们极端化思考：当数组被1填充满后，任何输入都会被判断为存在。</li>
</ol>
<p>所以布隆过滤器判断不存在的一定不存在，判断存在的可能有误判率。根据误判我们可以做一些提高准确性的工作：当判断存在时进行一次数据库查询，对误判建立白名单系统。当然，如果本身可接受极低的误判率，那通过尽可能降低误判率后忽略误判。</p>
<h3 id=公式>公式</h3>
<p>设过滤器数组的长度为m，插入的值的个数为n，hash函数的个数为k，误报率为ε。</p>
<ul>
<li>
<p>给定插入个数和误报率可得过滤器的长度为：$m=-{\frac {n\ln \varepsilon }{(\ln 2)^{2}}}$</p>
</li>
<li>
<p>给定m和n时最优hash函数个数为：$k={\frac {m}{n}}\ln 2$，给定误报率时hash函数个数为：$k=-\log _{2}\varepsilon $</p>
</li>
<li>
<p>给定m和n时误报率为：$\varepsilon \leq \left(1-e^{-{\frac {k(n+0.5)}{m-1}}}\right)^{k}$，当m比较大时，可以近似为：$\varepsilon \approx \left(1-e^{-{\frac {kn}{m}}}\right)^{k}$</p>
</li>
</ul>
<h3 id=图示示例>图示示例</h3>
<ol>
<li>
<p>设置一个[0,14]长度为15的数组，使用两个hash函数：<code>Fnv</code>和<code>Murmur</code>:</p>
<p><img src=https://static.fori.fun/blog/posts/img/bloom_filter_init.png alt=初始化></p>
</li>
<li>
<p>插入1，fnv(1)=7，murmur(1)=2：</p>
<p><img src=https://static.fori.fun/blog/posts/img/bloom_filter_add_1.png alt=初始化></p>
</li>
<li>
<p>插入3，fnv(3)=9，murmur(3)=14：</p>
<p><img src=https://static.fori.fun/blog/posts/img/bloom_filter_add_3.png alt=初始化></p>
</li>
<li>
<p>查询2，fnv(2)=8，murmur(2)=9，<code>Murmur</code>命中但<code>Fnv</code>未命中，所以肯定不存在2：</p>
<p><img src=https://static.fori.fun/blog/posts/img/bloom_filter_find_2.png alt=初始化></p>
</li>
<li>
<p>查询14，fnv(14)=2，murmur(14)=14，两个hash函数均命中，所以可能存在14：</p>
<p><img src=https://static.fori.fun/blog/posts/img/bloom_filter_find_14.png alt=初始化></p>
</li>
</ol>
<p>注：此处使用两个hash函数得出hash值后取余映射回了[0,14]区间，并非直接所得hash值。</p>
<h2 id=进阶>进阶</h2>
<p><strong>注：</strong> <em>仅供扩展了解，本人并未真正去推算</em></p>
<p>根据原理可知，该算法的时间复杂度为O(k)，也就是性能瓶颈为k个独立的hash函数。当误报率小于0.01%时，需要13个hash函数，这在频繁查询中也是一个很大的性能压力。<a href=https://static.fori.fun/blog/posts/file/bloom_filters_in_probabilistic_verification.pdf>《Bloom Filters in Probabilistic Verification》</a>这篇论文很好的解决了这个问题，将k个不同的hash函数转换成了2个hash函数的简单运算，其公式为：$g_{i}(x)=h_{1}(x)+ih_{2}(x)+i^{2}\bmod m,i\in \left(0,k \right)$</p>
<p>根据公式我们可以得到第i个hash函数的值而不需要真的准备k个hash函数去计算。这样只需要2个hash函数即可完成布隆过滤器。另一篇哈佛的论文：<a href=https://static.fori.fun/blog/posts/file/building_a_better_bloom_filter.pdf>《Less Hashing, Same Performance: Building a Better Bloom Filter》</a>对该方法有效性进行了证明。</p>
<h2 id=应用>应用</h2>
<p>我们只需要利用布隆过滤器真阴性性质就已经可以在IO查询前加入一层过滤系统来大大降低IO操作，如果可以容忍或者通过其他方式避免低概率的假阳性，那么可以用到更加广泛的方面。</p>
<p>业界常用的案例是垃圾邮件的过滤系统，爬虫的url去重系统。</p>
<p>实际上各种k-v储存都可以并且已经应用布隆过滤器来减少IO操作，比如Leveldb，Hbase。</p>
</div>
<div class=my-4>
<a href=/tags/%E6%9D%82%E9%A1%B9/ class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#杂项</a>
</div>
<div class="flex flex-col md:flex-row md:justify-between -mx-2 mt-4 px-2 pt-4 border-t">
<div>
<span class="block font-bold"></span>
<a href=/posts/%E4%BB%8E%E9%98%BF%E9%87%8C%E8%A7%84%E7%BA%A6%E8%B0%88%E8%B5%B7-%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E5%80%BC%E6%AF%94%E8%BE%83%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/ class=block>从阿里规约谈起-包装类的值比较注意事项</a>
</div>
<div class="md:text-right mt-4 md:mt-0">
<span class="block font-bold"></span>
<a href=/posts/%E4%BB%8E%E9%98%BF%E9%87%8C%E8%A7%84%E7%BA%A6%E8%B0%88%E8%B5%B7-arrays.aslist%E4%B8%89%E5%9D%91/ class=block>从阿里规约谈起-Arrays.asList 三坑</a>
</div>
</div>
</div>
<div class=col-span-2>
<div class="sticky top-16 z-10 hidden lg:block px-6 py-4 bg-primary-bg">
<span class="text-lg font-semibold"></span>
</div>
<div class="sticky-toc hidden lg:block px-6 pb-6">
<nav id=TableOfContents>
<ul>
<li><a href=#引言>引言</a></li>
<li><a href=#原理>原理</a>
<ul>
<li><a href=#初始化>初始化</a></li>
<li><a href=#插入>插入</a></li>
<li><a href=#查询>查询</a></li>
<li><a href=#误判>误判</a></li>
<li><a href=#公式>公式</a></li>
<li><a href=#图示示例>图示示例</a></li>
</ul>
</li>
<li><a href=#进阶>进阶</a></li>
<li><a href=#应用>应用</a></li>
</ul>
</nav>
</div>
<script>window.addEventListener('DOMContentLoaded',()=>{enableStickyToc()})</script>
</div>
</div>
<script>document.addEventListener('DOMContentLoaded',()=>{hljs.initHighlightingOnLoad()})</script>
</div>
</div>
</main>
<footer class=pl-scrollbar>
<div class="w-full max-w-screen-xl mx-auto"><div class="flex flex-col justify-center p-6">
<a class=mx-auto href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank>
<img src=https://static.fori.fun/blog/posts/img/cc_by_nc_sa.svg alt="CC BY-NC-SA 4.0" title="本博客均以《署名-非商业性使用-相同方式共享 4.0 国际》协议发布">
</a>
<p class="mx-auto pt-2 text-sm text-tertiary-text">&copy; 2021 <a href=https://blog.io01.xyz/>IO01</a>
&#183; Powered by the <a href=https://github.com/wangchucheng/hugo-eureka class=hover:text-eureka>Eureka</a> theme for <a href=https://gohugo.io class=hover:text-eureka>Hugo</a>
</p>
</div></div>
</footer>
</body>
</html>