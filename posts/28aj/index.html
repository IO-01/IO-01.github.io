<!doctype html><html class="scroll-pt-16 scroll-smooth" lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><link rel=icon href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'> <text x='0' y='14'>🧑‍💻</text> </svg>"><link rel=stylesheet href=https://blog.io01.xyz/css/style.css><script type=text/javascript src=https://blog.io01.xyz/js/main.js></script><title>从阿里规约谈起 - 禁用 Executors 创建线程池</title></head><body><header class="sticky top-0 z-10 bg-white backdrop-filter backdrop-blur-lg bg-opacity-70 border-b border-gray-200"><nav class="max-w-5xl mx-auto px-4"><div class="flex items-center justify-between h-16"><a href=/ class="text-2xl text-gray-900 font-semibold">IO01 Blog</a><ul class="flex space-x-4 text-gray-900"><li><a href=https://blog.io01.xyz/posts>归档</a></li><li><a href=https://blog.io01.xyz/about>关于</a></li></ul></div></nav></header><div id=content><div class="flex relative justify-center"><article class="w-5/6 md:w-2/3 xl:w-1/2 my-8 px-4 prose max-w-none prose-img:mx-auto"><header class="flex flex-col"><h1 class=text-center>从阿里规约谈起 - 禁用 Executors 创建线程池</h1><div class="flex-row mx-auto"><div class=inline-flex><div class="inline-flex items-center not-prose"><svg viewBox="0 0 1 1" class="h-4 mr-1"><use href="#calendar"/></svg><span class=text-gray-500>2019-08-30</span></div><div class="inline-flex items-center ml-2 not-prose"><svg viewBox="0 0 1 1" class="h-4 mx-1"><use href="#series"/></svg><a href=https://blog.io01.xyz/series/%E9%98%BF%E9%87%8C%E8%A7%84%E7%BA%A6/ class=text-gray-500>阿里规约</a></div><div class="inline-flex items-center ml-2 not-prose"><svg viewBox="0 0 1 1" class="h-4 mx-1"><use href="#tags"/></svg><a href=https://blog.io01.xyz/tags/java/ class="text-gray-500 mr-1">Java</a></div></div></div></header><h2 id=前言>前言</h2><p>Android 开发中耗时任务应该放在子线程中进行，否则会阻塞 UI 造成 ANR。但是如果直接创建子线程，阿里规约会提示：</p><p><img alt=直接使用子线程报错 title src=https://static.fori.fun/blog/posts/static/p3c_new_thread_error.png></p><p>关于禁止直接创建线程的原因如图，不再赘述。</p><h2 id=executors-被禁用原因>Executors 被禁用原因</h2><p>当我们转而选择线程池的时候，JDK 提供了一个简单的工厂模式来创建：<code>Executors</code>。</p><p>使用非常简单，四个方法可以创建四个不同类型的线程池，基本满足大部分线程池的使用需求。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#6272a4>//创建固定数目线程的线程池
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#6272a4></span>Executors<span style=color:#ff79c6>.</span><span style=color:#50fa7b>newFixedThreadPool</span><span style=color:#ff79c6>(</span><span style=color:#8be9fd>int</span> nThreads<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span><span style=color:#6272a4>//创建一个唯一线程的线程池
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span><span style=color:#6272a4></span>Executors<span style=color:#ff79c6>.</span><span style=color:#50fa7b>newSingleThreadExecutor</span><span style=color:#ff79c6>()</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span><span style=color:#6272a4>//创建一个可缓存的线程池
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span><span style=color:#6272a4></span>Executors<span style=color:#ff79c6>.</span><span style=color:#50fa7b>newCachedThreadPool</span><span style=color:#ff79c6>()</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span><span style=color:#6272a4>//创建一个支持定时及周期性的任务执行的线程池
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span><span style=color:#6272a4></span>Executors<span style=color:#ff79c6>.</span><span style=color:#50fa7b>newScheduledThreadPool</span><span style=color:#ff79c6>(</span><span style=color:#8be9fd>int</span> corePoolSize<span style=color:#ff79c6>)</span>
</span></span></code></pre></div><p>但是如果使用了，会发现阿里规约再次禁止：</p><p><img alt="使用 Executors 报错" title src=https://static.fori.fun/blog/posts/static/p3c_executors_error.png>
约定禁止的原因如下：</p><p>对于 <code>newFiexedThreadPool</code> 和 <code>newSingleThreadExecutor</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> ExecutorService <span style=color:#50fa7b>newFixedThreadPool</span><span style=color:#ff79c6>(</span><span style=color:#8be9fd>int</span> nThreads<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> ThreadPoolExecutor<span style=color:#ff79c6>(</span>nThreads<span style=color:#ff79c6>,</span> nThreads<span style=color:#ff79c6>,</span> <span style=color:#bd93f9>0</span>L<span style=color:#ff79c6>,</span> TimeUnit<span style=color:#ff79c6>.</span><span style=color:#50fa7b>MILLISECONDS</span><span style=color:#ff79c6>,</span> <span style=color:#ff79c6>new</span> LinkedBlockingQueue<span style=color:#ff79c6>&lt;&gt;());</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> ExecutorService <span style=color:#50fa7b>newSingleThreadExecutor</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> FinalizableDelegatedExecutorService
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>            <span style=color:#ff79c6>(</span><span style=color:#ff79c6>new</span> ThreadPoolExecutor<span style=color:#ff79c6>(</span><span style=color:#bd93f9>1</span><span style=color:#ff79c6>,</span> <span style=color:#bd93f9>1</span><span style=color:#ff79c6>,</span> <span style=color:#bd93f9>0</span>L<span style=color:#ff79c6>,</span> TimeUnit<span style=color:#ff79c6>.</span><span style=color:#50fa7b>MILLISECONDS</span><span style=color:#ff79c6>,</span> <span style=color:#ff79c6>new</span> LinkedBlockingQueue<span style=color:#ff79c6>&lt;&gt;()));</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>原因是请求队列为 <code>LinkedBlockingQueue</code> 的默认实现，跟踪代码可以看到：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#50fa7b>LinkedBlockingQueue</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>    <span style=color:#ff79c6>this</span><span style=color:#ff79c6>(</span>Integer<span style=color:#ff79c6>.</span><span style=color:#50fa7b>MAX_VALUE</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>在其默认实现中，队列长度为 <code>Integer</code> 最大值。</p><p>对于 <code>newCachedThreadPool</code> 和 <code>newScheduledThreadPool</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> ExecutorService <span style=color:#50fa7b>newCachedThreadPool</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> ThreadPoolExecutor<span style=color:#ff79c6>(</span><span style=color:#bd93f9>0</span><span style=color:#ff79c6>,</span> Integer<span style=color:#ff79c6>.</span><span style=color:#50fa7b>MAX_VALUE</span><span style=color:#ff79c6>,</span> <span style=color:#bd93f9>60L</span><span style=color:#ff79c6>,</span> TimeUnit<span style=color:#ff79c6>.</span><span style=color:#50fa7b>SECONDS</span><span style=color:#ff79c6>,</span> <span style=color:#ff79c6>new</span> SynchronousQueue<span style=color:#ff79c6>&lt;&gt;());</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#50fa7b>ScheduledThreadPoolExecutor</span><span style=color:#ff79c6>(</span><span style=color:#8be9fd>int</span> corePoolSize<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>    <span style=color:#8be9fd;font-style:italic>super</span><span style=color:#ff79c6>(</span>corePoolSize<span style=color:#ff79c6>,</span> Integer<span style=color:#ff79c6>.</span><span style=color:#50fa7b>MAX_VALUE</span><span style=color:#ff79c6>,</span> DEFAULT_KEEPALIVE_MILLIS<span style=color:#ff79c6>,</span> MILLISECONDS<span style=color:#ff79c6>,</span> <span style=color:#ff79c6>new</span> DelayedWorkQueue<span style=color:#ff79c6>());</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>原因是最大线程数为 <code>Integer</code> 最大值。</p><p>这四个方法如果直接使用默认模式，无一幸免均可能因为线程太多而造成 OOM。</p><h2 id=使用-threadpoolexecutor-手动创建线程池>使用 ThreadPoolExecutor 手动创建线程池</h2><p>综上，我们需要使用 <code>ThreadPoolExecutor</code> 手动创建线程池。</p><p><code>ThreadPoolExecutor</code> 一般需要关心的参数如下：</p><ul><li><code>corePoolSize</code>：核心线程数量</li><li><code>maximumPoolSize</code>：最大线程数量</li><li><code>keepAliveTime</code> 和 <code>unit</code>：非核心线程空闲后的存活时间</li><li><code>workQueue</code>：保存等待执行的任务的阻塞队列</li><li><code>handler</code>：队列和最大线程都满了之后的饱和策略</li></ul><p>其中 <code>workQueue</code> 的常用类型为：</p><ul><li><code>SynchronousQueue</code>：这个队列接收到任务的时候，会直接提交给线程处理，而不保留它</li><li><code>LinkedBlockingQueue</code>：这个队列接收到任务的时候，如果当前线程数等于核心线程数，则进入队列等待。由于这个队列默认没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了 <code>maximumPoolSize</code> 的设定失效，因为总线程数永远不会超过 <code>corePoolSize</code></li><li><code>ArrayBlockingQueue</code>：可以限定队列的长度，接收到任务的时候，如果当前线程数等于核心线程数，则入队等候，如果队列已满，则新建非核心线程执行任务</li><li><code>DelayQueue</code>：队列内元素必须实现 Delayed 接口，这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务</li></ul><p>线程池执行任务时的策略如下：</p><ol><li>线程数量未达到 <code>corePoolSize</code>，则新建一个线程（核心线程）执行任务</li><li>线程数量达到了 <code>corePools</code>，则将任务移入队列等待</li><li>队列已满，新建线程（非核心线程）执行任务</li><li>队列已满，总线程数又达到了 <code>maximumPoolSize</code>，就会由 <code>handler</code> 执行饱和策略（一般是抛出异常）</li></ol><h2 id=协程>协程</h2><p>对于现在的开发来说最简单的方案应该是换 Kotlin 使用协程，Kotlin 内置了多个线程池给我们用：</p><ul><li><code>Dispatchers.Main</code> - 主线程，用于界面更新。</li><li><code>Dispatchers.IO</code> - I/O 线程池。用于读写数据库和网络请求。</li><li><code>Dispatchers.Default</code> - CPU 线程池。用于重 CPU 操作。</li></ul><div class="flex flex-row justify-between"><div class=not-prose><a class="inline-flex items-center group text-gray-400 hover:text-sky-400" href=https://blog.io01.xyz/posts/6tf9/><svg viewBox="0 0 1 1" class="fill-gray-400 group-hover:fill-sky-400 h-4 mx-1"><use href="#angle-left"/></svg>从阿里规约谈起 - HashMap 初始化和扩容相关</a></div><div class=not-prose></div></div></article><aside class="fixed md:left-5/6 xl:left-3/4 hidden md:block top-16 w-1/6 max-h-screen p-4 shadow-md"><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#executors-被禁用原因>Executors 被禁用原因</a></li><li><a href=#使用-threadpoolexecutor-手动创建线程池>使用 ThreadPoolExecutor 手动创建线程池</a></li><li><a href=#协程>协程</a></li></ul></nav></aside></div></div><footer><div class="flex justify-center mt-6 mb-2 text-gray-500"><span>&copy;2023
<span class=ml-2><a class=hover:text-sky-400 href=https://blog.io01.xyz>IO01</a></span></span>
<span class=mx-2>|</span>
<span>Powered by
<a class=hover:text-sky-400 href=https://gohugo.io>Hugo</a></span>
<span class=mx-1>&</span>
<span><a class=hover:text-sky-400 href=#>FullMoon</a></span></div></footer></body></html>