<!doctype html><html lang><meta charset=utf-8>
<meta name=viewport content="width=device-width">
<title>深入源码排查 FLAG_ACTIVITY_NEW_TASK 导致的 Activity 无法正常启动 | IO01 Blog</title>
<meta name=generator content="Hugo Eureka 0.8.0">
<link rel=stylesheet href=/css/eureka.min.css>
<script defer src=/js/eureka.min.js></script>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin>
<link rel=preload href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap" as=style onload="this.onload=null,this.rel='stylesheet'">
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/solarized-light.min.css media=print onload="this.media='all',this.onload=null" crossorigin>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/languages/dart.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js integrity="sha256-uNYoXefWRqv+PsIF/OflNmwtKM4lStn9yrz2gVl6ymo=" crossorigin></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X media=print onload="this.media='all',this.onload=null" crossorigin>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script>
<script defer src=https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js integrity="sha256-Zmpaaj+GXFsPF5WdPArSrnW3b30dovldeKsW00xBVwE=" crossorigin></script>
<link rel=icon type=image/png sizes=32x32 href=/images/favicon_huc32cac3e9dc2dba9d765d255923cde91_27863_32x32_fill_box_center_3.png>
<link rel=apple-touch-icon sizes=180x180 href=/images/favicon_huc32cac3e9dc2dba9d765d255923cde91_27863_180x180_fill_box_center_3.png>
<meta name=description content="引言 众所周知 Android 中 Activity 有四种启动模式，决定了是否创建新的 Activity 实例或复用当前实例。但是实际上 Activity 的启动十分复杂，不单单是 android:launchMode 就能决定的，多个 Intent Flag 都能改变启动的行为">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":2,"name":"深入源码排查 FLAG_ACTIVITY_NEW_TASK 导致的 Activity 无法正常启动","item":"/posts/%E6%B7%B1%E5%85%A5%E6%BA%90%E7%A0%81%E6%8E%92%E6%9F%A5-flag_activity_new_task-%E5%AF%BC%E8%87%B4%E7%9A%84-activity-%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/%E6%B7%B1%E5%85%A5%E6%BA%90%E7%A0%81%E6%8E%92%E6%9F%A5-flag_activity_new_task-%E5%AF%BC%E8%87%B4%E7%9A%84-activity-%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8/"},"headline":"深入源码排查 FLAG_ACTIVITY_NEW_TASK 导致的 Activity 无法正常启动 | IO01 Blog","datePublished":"2021-09-16T00:00:00+00:00","dateModified":"2021-09-16T00:00:00+00:00","wordCount":4751,"publisher":{"@type":"Person","name":"C. Wang","logo":{"@type":"ImageObject","url":"/images/favicon.png"}},"description":"引言 众所周知 Android 中 Activity 有四种启动模式，决定了是否创建新的 Activity 实例或复用当前实例。但是实际上 Activity 的启动十分复杂，不单单是 android:launchMode 就能决定的，多个 Intent Flag 都能改变启动的行为"}</script><meta property="og:title" content="深入源码排查 FLAG_ACTIVITY_NEW_TASK 导致的 Activity 无法正常启动 | IO01 Blog">
<meta property="og:type" content="article">
<meta property="og:image" content="/images/favicon.png">
<meta property="og:url" content="/posts/%E6%B7%B1%E5%85%A5%E6%BA%90%E7%A0%81%E6%8E%92%E6%9F%A5-flag_activity_new_task-%E5%AF%BC%E8%87%B4%E7%9A%84-activity-%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8/">
<meta property="og:description" content="引言 众所周知 Android 中 Activity 有四种启动模式，决定了是否创建新的 Activity 实例或复用当前实例。但是实际上 Activity 的启动十分复杂，不单单是 android:launchMode 就能决定的，多个 Intent Flag 都能改变启动的行为">
<meta property="og:site_name" content="IO01 Blog">
<meta property="article:published_time" content="2021-09-16T00:00:00+00:00">
<meta property="article:modified_time" content="2021-09-16T00:00:00+00:00">
<meta property="article:section" content="posts">
<meta property="article:tag" content="源码">
<body class="flex flex-col min-h-screen">
<header class="fixed flex items-center w-full min-h-16 pl-scrollbar z-50 bg-secondary-bg shadow-sm">
<div class="w-full max-w-screen-xl mx-auto"><script>let storageColorScheme=localStorage.getItem("lightDarkMode");((storageColorScheme=='Auto'||storageColorScheme==null)&&window.matchMedia("(prefers-color-scheme: dark)").matches||storageColorScheme=="Dark")&&document.getElementsByTagName('html')[0].classList.add('dark')</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
<a href=/ class="mr-6 text-primary-text text-xl font-bold">IO01 Blog</a>
<button id=navbar-btn class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
<i class="fas fa-bars"></i>
</button>
<div id=target class="hidden block md:flex md:flex-grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
<div class="md:flex md:h-16 text-sm md:flex-grow pb-4 md:pb-0 border-b md:border-b-0">
</div>
<div class=flex>
<div class="relative pt-4 md:pt-0">
<div class="cursor-pointer hover:text-eureka" id=lightDarkMode>
<i class="fas fa-adjust"></i>
</div>
<div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id=is-open>
</div>
<div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40" id=lightDarkOptions>
<span class="px-4 py-1 hover:text-eureka" name=Light></span>
<span class="px-4 py-1 hover:text-eureka" name=Dark></span>
<span class="px-4 py-1 hover:text-eureka" name=Auto></span>
</div>
</div>
</div>
</div>
<div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id=is-open-mobile>
</div>
</nav>
<script>let element=document.getElementById('lightDarkMode');storageColorScheme==null||storageColorScheme=='Auto'?document.addEventListener('DOMContentLoaded',()=>{window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change',switchDarkMode)}):storageColorScheme=="Light"?(element.firstElementChild.classList.remove('fa-adjust'),element.firstElementChild.setAttribute("data-icon",'sun'),element.firstElementChild.classList.add('fa-sun')):storageColorScheme=="Dark"&&(element.firstElementChild.classList.remove('fa-adjust'),element.firstElementChild.setAttribute("data-icon",'moon'),element.firstElementChild.classList.add('fa-moon')),document.addEventListener('DOMContentLoaded',()=>{getcolorscheme(),switchBurger()})</script>
</div>
</header>
<main class="flex-grow pt-16">
<div class=pl-scrollbar>
<div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto">
<div class="grid grid-cols-2 lg:grid-cols-8 gap-4 lg:pt-12">
<div class="col-span-2 lg:col-span-6 bg-secondary-bg rounded px-6 py-8">
<h1 class="font-bold text-3xl text-primary-text">深入源码排查 FLAG_ACTIVITY_NEW_TASK 导致的 Activity 无法正常启动</h1>
<div class="flex flex-wrap flex-row items-center mt-2 text-tertiary-text">
<div class="mr-6 my-2">
<i class="fas fa-calendar mr-1"></i>
<span>2021-09-16</span>
</div>
</div>
<div class=content>
<h2 id=引言>引言</h2>
<p>众所周知 Android 中 Activity 有四种启动模式，决定了是否创建新的 Activity 实例或复用当前实例。但是实际上 Activity 的启动十分复杂，不单单是 <code>android:launchMode</code> 就能决定的，多个 Intent Flag 都能改变启动的行为模式，除此之外还会根据 <code>android:taskAffinity</code> 的值来判断对应任务栈是否存在。</p>
<h3 id=基本-launchmode-行为模式>基本 LaunchMode 行为模式</h3>
<p>首先复习一下最基本的 LaunchMode 行为模式：</p>
<ul>
<li>
<p>standard：默认值，每次启动都会创建一个新的 Activity 实例。</p>
</li>
<li>
<p>singleTop：如果待启动 Activity 处于栈顶则重用实例回调其 <code>onNewIntent()</code> 方法，否则新建实例。</p>
</li>
<li>
<p>singleTask：如果已有任务栈中存在该 Activity 实例，则将实例之上的其他 Activity 清空并回调实例的 <code>onNewIntent()</code> 方法，否则新建栈创建 Activity 实例。</p>
</li>
<li>
<p>singleInstance：在单独一个栈中创建，该栈不会再创建其他 Activity，当系统中存在实例时回调实例的 <code>onNewIntent()</code> 方法。</p>
</li>
</ul>
<p>这是我们最熟知的启动模式，但是需要注意的是：上述行为模式仅限于未添加任何 Flag，并且没有改变 taskAffinity 的前提下。</p>
<h3 id=service-启动-activity>Service 启动 Activity</h3>
<p>如前所述，如果单纯的 Activity 启动 Activiy 且不添加任何 Flag 是没问题的，但是如果我们使用 Service 启动 Activity 就会遇到一个异常，在 Framework（本文 Framework 源码均来自 Android 11 版本）的源码中会抛出异常：</p>
<pre><code class=language-java>// android.app.ContextImpl
@Override
public void startActivity(Intent intent, Bundle options) {
    ……
    if ((intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NEW_TASK) == 0
            &amp;&amp; (targetSdkVersion &lt; Build.VERSION_CODES.N || targetSdkVersion &gt;= Build.VERSION_CODES.P)
            &amp;&amp; (options == null || ActivityOptions.fromBundle(options).getLaunchTaskId() == -1)) {
        throw new AndroidRuntimeException(
                &quot;Calling startActivity() from outside of an Activity &quot;
                        + &quot; context requires the FLAG_ACTIVITY_NEW_TASK flag.&quot;
                        + &quot; Is this really what you want?&quot;);
    }
    ……
}
</code></pre>
<p>所以在 Service 中启动 Activity 必须添加 <code>FLAG_ACTIVITY_NEW_TASK</code>，原因也很简单，每个 Activity 启动都需要一个任务栈，非 Activity 的 context 存在后台启动的可能，而此时前台是其他 App 的任务栈，甚至我们的 App 根本没有创建过任务栈，为了防止这些无法预料的情况出现，被强制要求添加这个 Flag。</p>
<p><code>standard</code> 是四种启动模式中最简单也最常见的，其他三种各有各的流程，唯独 <code>standard</code> 直接简单粗暴创建一个新的实例放到栈顶。那么问题来了，是否所有的 <code>standard</code> 都能创建一个新的实例呢？</p>
<h2 id=无法启动的-standard-activity>无法启动的 <code>standard</code> Activity</h2>
<h3 id=复现流程>复现流程</h3>
<p>将所有不影响异常的业务代码删除之后得到的最精简复现流程如下：</p>
<ol>
<li>
<p>Service 附加 <code>FLAG_ACTIVITY_NEW_TASK</code> 启动 A_Activity：</p>
<pre><code class=language-kotlin>startActivity(Intent(this, AActivity::class.java).apply { addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) })
</code></pre>
</li>
<li>
<p>A_Activity 启动 B_Activity：</p>
<pre><code class=language-kotlin>startActivity(Intent(this, BActivity::class.java))
</code></pre>
</li>
<li>
<p>Service 附加 <code>FLAG_ACTIVITY_NEW_TASK</code> 启动 A_Activity：</p>
<pre><code class=language-kotlin>startActivity(Intent(this, AActivity::class.java).apply { addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) })
</code></pre>
</li>
</ol>
<p>会发现 A_Activity 无法被启动，A_Activity 和 B_Activity 均未回调 <code>onCreate</code>、<code>onResume</code> 或者 <code>onNewIntent</code> 等生命周期函数，也没有任何 Crash 或者 ANR 的日志发生，点击 B_Activity 可以正常操作。</p>
<h3 id=原因推测>原因推测</h3>
<p>首先排除 Service 的 Context 的原因，因为我们可以构造如下流程，实验会发现 A_Activity 依然无法启动：</p>
<ol>
<li>
<p>MainActivity 中先 <code>finish</code> 后附加 <code>FLAG_ACTIVITY_NEW_TASK</code> 启动 A_Activity：</p>
<pre><code class=language-kotlin>finish()
startActivity(Intent(this, AActivity::class.java).apply { addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) })
</code></pre>
</li>
<li>
<p>A_Activity 启动 B_Activity：</p>
<pre><code class=language-kotlin>startActivity(Intent(this, BActivity::class.java))
</code></pre>
</li>
<li>
<p>B_Activity 附加 <code>FLAG_ACTIVITY_NEW_TASK</code> 启动 A_Activity：</p>
<pre><code class=language-kotlin>startActivity(Intent(this, AActivity::class.java).apply { addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) })
</code></pre>
</li>
</ol>
<p>那么从使用排除法得到 <code>FLAG_ACTIVITY_NEW_TASK</code> 有可能是原因了。另外细心观察上面的步骤，会发现第一步先 <code>finish</code> 再 <code>startActivity</code>，如果去掉 <code>finish</code> 做实验会发现其实可以成功启动 A_Activity，那么另一个原因应该就是 <code>finish</code> 了。</p>
<h3 id=源码追踪>源码追踪</h3>
<h4 id=startactivityinner>startActivityInner</h4>
<p>Framework 的 Activity 启动源码非常繁杂，但是真正对 Activity 栈进行操作的函数是 <code>ActivityStarter#startActivityInner</code>，所以我们将着重分析这个方法。</p>
<pre><code class=language-java>// com.android.server.wm.ActivityStarter
int startActivityInner(final ActivityRecord r, ActivityRecord sourceRecord,
        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
        int startFlags, boolean doResume, ActivityOptions options, Task inTask,
        boolean restrictedBgActivity, NeededUriGrants intentGrants) {
    setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,
            voiceInteractor, restrictedBgActivity);

    // 计算 Activity 的启动 Flag
    computeLaunchingTaskFlags();
    ……
    // 确定是否将新 Activity 插入现有任务栈中，如果是则返回对应的 ActivityRecord，否则返回 null
    final Task reusedTask = getReusableTask();
    ……
    // 计算是否存在可用的任务栈
    final Task targetTask = reusedTask != null ? reusedTask : computeTargetTask();
    final boolean newTask = targetTask == null;
    mTargetTask = targetTask;

    computeLaunchParams(r, sourceRecord, targetTask);

    // 检查是否允许在给定任务栈或者新栈上启动 Activity
    int startResult = isAllowedToStart(r, newTask, targetTask);
    if (startResult != START_SUCCESS) {
        return startResult;
    }

    final ActivityRecord targetTaskTop = newTask ? null : targetTask.getTopNonFinishingActivity();
    if (targetTaskTop != null) {
        // 为了这次启动回收目标任务栈
        startResult = recycleTask(targetTask, targetTaskTop, reusedTask, intentGrants);
        if (startResult != START_SUCCESS) {
            return startResult;
        }
    } else {
        mAddingToTask = true;
    }
    ……
}
</code></pre>
<p>由于 <code>startActivityInner</code> 方法依然比较长，所以将只看几个可能产生影响的地方，对任务栈有影响的关键方法是 <code>getReusableTask</code> 和 <code>recycleTask</code>。</p>
<h4 id=getreusabletask>getReusableTask</h4>
<p>首先先看看 <code>getReusableTask</code> 的源码：</p>
<pre><code class=language-java>// com.android.server.wm.ActivityStarter
private Task getReusableTask() {
    // 新 Activity 放到现有任务栈中的条件：
    // 1. Flags 包含 FLAG_ACTIVITY_NEW_TASK 但是不包含 FLAG_ACTIVITY_MULTIPLE_TASK
    // 2. launchMode 是 singleInstance 或 singleTask
    boolean putIntoExistingTask = ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != 0 &amp;&amp;
            (mLaunchFlags &amp; FLAG_ACTIVITY_MULTIPLE_TASK) == 0)
            || isLaunchModeOneOf(LAUNCH_SINGLE_INSTANCE, LAUNCH_SINGLE_TASK);
    putIntoExistingTask &amp;= mInTask == null &amp;&amp; mStartActivity.resultTo == null;
    ActivityRecord intentActivity = null;
    if (putIntoExistingTask) {
        if (LAUNCH_SINGLE_INSTANCE == mLaunchMode) {
            // singleInstance 相关
            intentActivity = mRootWindowContainer.findActivity(mIntent, mStartActivity.info,
                    mStartActivity.isActivityTypeHome());
        } else if ((mLaunchFlags &amp; FLAG_ACTIVITY_LAUNCH_ADJACENT) != 0) {
            // 分屏相关
            intentActivity = mRootWindowContainer.findActivity(mIntent, mStartActivity.info,
                    !(LAUNCH_SINGLE_TASK == mLaunchMode));
        } else {
            // 除上述情况之外的情况寻找最合适的任务栈
            intentActivity =
                    mRootWindowContainer.findTask(mStartActivity, mPreferredTaskDisplayArea);
        }
    }
    ……
    return intentActivity != null ? intentActivity.getTask() : null;
}
</code></pre>
<p>根据上述源码，由于我们的 Flags 中包含 <code>FLAG_ACTIVITY_NEW_TASK</code> 但是不包含 <code>FLAG_ACTIVITY_MULTIPLE_TASK</code>，所以会从现有的任务栈中寻找一个最合适的任务栈并将待启动的 Activity 插入其中，在我们举的例子中，会获取到 B_Activity 所在的任务栈。</p>
<h4 id=recycletask>recycleTask</h4>
<p>接着来看看 <code>recycleTask</code> 的源码：</p>
<pre><code class=language-java>// com.android.server.wm.ActivityStarter
int recycleTask(Task targetTask, ActivityRecord targetTaskTop, Task reusedTask,
        NeededUriGrants intentGrants) {
    // 不同用户下不回收任务栈，直接启动 Activity 并添加到任务栈中
    if (targetTask.mUserId != mStartActivity.mUserId) {
        mTargetStack = targetTask.getStack();
        mAddingToTask = true;
        // 第一处 return
        return START_SUCCESS;
    }
    ……
    setTargetStackIfNeeded(targetTaskTop);
    ……
    // START_FLAG_ONLY_IF_NEEDED 表示启动和被启动者是同一个
    if ((mStartFlags &amp; START_FLAG_ONLY_IF_NEEDED) != 0) {
        if (!mMovedToFront &amp;&amp; mDoResume) {
            ……
            mTargetStack.moveToFront(&quot;intentActivityFound&quot;);
        }
        resumeTargetStackIfNeeded();
        // 第二处 return
        return START_RETURN_INTENT_TO_CALLER;
    }

    complyActivityFlags(targetTask,
            reusedTask != null ? reusedTask.getTopNonFinishingActivity() : null, intentGrants);
    ……
    if (mAddingToTask) {
        // 第三处 return
        return START_SUCCESS;
    }
    ……
    resumeTargetStackIfNeeded();
    mLastStartActivityRecord =
            targetTaskTop.finishing ? targetTask.getTopNonFinishingActivity() : targetTaskTop;
    // 第四处 return
    return mMovedToFront ? START_TASK_TO_FRONT : START_DELIVERED_TO_TOP;
}
</code></pre>
<p>根据单步调试，我们可以知道 <code>recycleTask</code> 返回的结果是 <code>START_DELIVERED_TO_TOP</code>，在 <code>startActivityInner</code> 中 <code>recycleTask</code> 部分的相关代码是：</p>
<pre><code class=language-java>// com.android.server.wm.ActivityStarter#startActivityInner
startResult = recycleTask(targetTask, targetTaskTop, reusedTask, intentGrants);
if (startResult != START_SUCCESS) {
    return startResult;
}
</code></pre>
<p>即根本没有运行 <code>startActivityInner</code> 后半部分代码，启动失败原因就在于此，因此不再逐一解析 <code>recycleTask</code>，而是着眼于为何没有返回 <code>START_SUCCESS</code>，可以逐一寻找 <code>recycleTask</code> 中所有 <code>return</code> 的地方：</p>
<ol>
<li>同一用户环境下，因此不会返回 <code>START_SUCCESS</code></li>
<li><code>START_FLAG_ONLY_IF_NEEDED</code> 表示启动和被启动者是同一个 Activity，因此不会返回 <code>START_RETURN_INTENT_TO_CALLER</code></li>
<li>根据 <code>mAddingToTask</code> 是否为 <code>true</code> 来确定是否返回 <code>START_SUCCESS</code>，关联方法是 <code>complyActivityFlags</code>，此处需要分析一下为何 <code>mAddingToTask</code> 为 <code>false</code></li>
<li>根据 <code>mMovedToFront</code> 判断返回为 <code>START_TASK_TO_FRONT</code> 还是 <code>START_DELIVERED_TO_TOP</code>，关联的方法是 <code>setTargetStackIfNeeded</code>，由于上一步已经断绝了返回 <code>START_SUCCESS</code> 的可能，无法正常创建一个 Activity 实例了，就不再分析此方法。</li>
</ol>
<h4 id=complyactivityflags>complyActivityFlags</h4>
<pre><code class=language-java>// com.android.server.wm.ActivityStarter
private void complyActivityFlags(Task targetTask, ActivityRecord reusedActivity,
        NeededUriGrants intentGrants) {
    ActivityRecord targetTaskTop = targetTask.getTopNonFinishingActivity();
    final boolean resetTask =
            reusedActivity != null &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0;
    if (resetTask) {
        targetTaskTop = mTargetStack.resetTaskIfNeeded(targetTaskTop, mStartActivity);
    }

    if ((mLaunchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))
            == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) {
        // 如果设置了 FLAG_ACTIVITY_NEW_TASK 和 FLAG_ACTIVITY_CLEAR_TASK
        // 清除目标任务栈上所有的 Activity，并将待启动 Activity 的 intent 信息设置给目标任务栈
        targetTask.performClearTaskLocked();
        targetTask.setIntent(mStartActivity);
        mAddingToTask = true;
    } else if ((mLaunchFlags &amp; FLAG_ACTIVITY_CLEAR_TOP) != 0
            || isDocumentLaunchesIntoExisting(mLaunchFlags)
            || isLaunchModeOneOf(LAUNCH_SINGLE_INSTANCE, LAUNCH_SINGLE_TASK)) {
        // 如果设置了 FLAG_ACTIVITY_CLEAR_TOP；android:documentLaunchMode（最近任务列表相关属性）的值是 intoExisting，代表 Activity 重复使用文档的现有任务；launchMode 是 singleInstance 或 singleTask
        // 清除待启动 Activity 在任务栈之上的所有 Activity
        final ActivityRecord top = targetTask.performClearTaskForReuseLocked(mStartActivity,
                mLaunchFlags);

        if (targetTaskTop.getTask() == null) {
            targetTask.addChild(targetTaskTop);
        }

        if (top != null) {
            if (top.isRootOfTask()) {
                top.getTask().setIntent(mStartActivity);
            }
            deliverNewIntent(top, intentGrants);
        } else {
            mAddingToTask = true;
            if (targetTask.getStack() == null) {
                mTargetStack =
                        getLaunchStack(mStartActivity, mLaunchFlags, null /* task */, mOptions);
                mTargetStack.addChild(targetTask, !mLaunchTaskBehind /* toTop */,
                        (mStartActivity.info.flags &amp; FLAG_SHOW_FOR_ALL_USERS) != 0);
            }
        }
    } else if ((mLaunchFlags &amp; FLAG_ACTIVITY_CLEAR_TOP) == 0 &amp;&amp; !mAddingToTask
            &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
        // 如果设置了 FLAG_ACTIVITY_REORDER_TO_FRONT、没有设置 FLAG_ACTIVITY_CLEAR_TOP 且待启动 Activity 已经在运行中
        // 将待启动 Activity 提到栈顶并回调 onNewIntent
        final ActivityRecord act =
                targetTask.findActivityInHistory(mStartActivity.mActivityComponent);
        if (act != null) {
            final Task task = act.getTask();
            task.moveActivityToFrontLocked(act);
            act.updateOptionsLocked(mOptions);
            deliverNewIntent(act, intentGrants);
            mTargetStack.mLastPausedActivity = null;
        } else {
            mAddingToTask = true;
        }
    } else if (mStartActivity.mActivityComponent.equals(targetTask.realActivity)) {
        // 待启动 Activity 的完整组件名如果和目标栈启动栈的 Activity 相同
        if (targetTask == mInTask) {
            // 目标任务栈和指定任务栈相同
            // 不新建 Activity 实例
        } else if (((mLaunchFlags &amp; FLAG_ACTIVITY_SINGLE_TOP) != 0
                        || LAUNCH_SINGLE_TOP == mLaunchMode)
                &amp;&amp; targetTaskTop.mActivityComponent.equals(mStartActivity.mActivityComponent)
                &amp;&amp; mStartActivity.resultTo == null) {
            // singleTop 模式下
            // 回调 onNewIntent
            if (targetTaskTop.isRootOfTask()) {
                targetTaskTop.getTask().setIntent(mStartActivity);
            }
            deliverNewIntent(targetTaskTop, intentGrants);
        } else if (!targetTask.isSameIntentFilter(mStartActivity)) {
            // 目标任务栈和待启动 Activity 的 Intent Filter 不同
            // 新建 Activity 实例
            mAddingToTask = true;
        } else if (reusedActivity == null) {
            // 没用复用的 Activity
            // 新建 Activity 实例
            mAddingToTask = true;
        }
    } else if (!resetTask) {
        // 一般从快捷图标或通知中启动
        // 需要添加新的 Activity 到 Task 最上面
        mAddingToTask = true;
    } else if (!targetTask.rootWasReset) {
        // 希望把待启动 Activity 放到目标任务栈底部，但是现在的代码结构做不到，只把待启动 Activity 的 Intent 设置给目标任务栈
        targetTask.setIntent(mStartActivity);
    }
}
</code></pre>
<p>当我们单步调试进 <code>complyActivityFlags</code> 会发现，只设置了 <code>FLAG_ACTIVITY_NEW_TASK</code>，没有设置 <code>FLAG_ACTIVITY_CLEAR_TASK</code>、<code>FLAG_ACTIVITY_CLEAR_TOP</code>、<code>FLAG_ACTIVITY_REORDER_TO_FRONT</code>；启动模式是 <code>standard</code>；虽然待启动 Activity 的完整组件名如果和目标栈启动栈的 Activity 相同，但是却又不符合下面的所有判断；虽然可以进入 <code>!resetTask</code> 的分支却被上一个分支截胡……总之完美避过了所有能正常启动的 case。</p>
<h4 id=resumetopactivityinnerlocked>resumeTopActivityInnerLocked</h4>
<p>那么不能创建新的 Activity 实例会发生什么呢，这就需要关注 <code>recycleTask</code> 中的一个方法：<code>resumeTargetStackIfNeeded</code>，位于 <code>complyActivityFlags</code> 之后，用于将目标返回栈栈顶的 Activity 回调 <code>onResume</code> 方法，即虽然没有启动 A_Activity，但是把 B_Activity 给重新可见了。由于调用链路过长不多分析，但是层层调用后有一点需要关注，在 <code>ActivityStack#resumeTopActivityInnerLocked</code> 中：</p>
<pre><code class=language-java>// com.android.server.wm.ActivityStack#resumeTopActivityInnerLocked
if (mResumedActivity == next &amp;&amp; next.isState(RESUMED)
        &amp;&amp; taskDisplayArea.allResumedActivitiesComplete()) {
    executeAppTransition(options);
    if (DEBUG_STATES) Slog.d(TAG_STATES,
            &quot;resumeTopActivityLocked: Top activity resumed &quot; + next);
    return false;
}
</code></pre>
<p>B_Activity 本身就是 <code>RESUMED</code> 状态，所以会进入这个分支，不再继续 <code>resumeTopActivityInnerLocked</code> 后面的回调 <code>onResume</code> 逻辑直接返回。这就解释了为何 B_Activity 没有生命周期变化。</p>
<h3 id=原因总结>原因总结</h3>
<p>我们原因推测时猜想 <code>FLAG_ACTIVITY_NEW_TASK</code> 可以得到证实，那么猜想 MainActivity 的 <code>finish</code> 是在哪里造成影响的呢？其实是 <code>complyActivityFlags</code> 的分支顺序，如果不 finish，目标任务栈启动栈的 Activity 是 MainActivity，跟 A_Activity 不同名，所以会进入 <code>!resetTask</code> 分支，但是如果 finish 掉 MainActivity，目标任务栈启动栈的 Activity 就是第一次启动的 A_Activity，会被截胡而无法进入 <code>!resetTask</code> 分支。</p>
<p>简单总结一下就是因为启动 Flag，启动模式，现有栈的情况种种机缘巧合，让分支逐一落空导致没有任何 Activity 被启动，既不会回调 <code>onNewIntent</code> 也不会新建一个 Activity 实例。原本会将目标返回栈栈顶的 Activity（即 B_Activity）重新 resume，但是巧合的是 B_Activity 本来就是 <code>RESUMED</code> 状态，所以也就不会回调 B_Activity 的 <code>onResume</code>。种种巧合之下的结果就是看上去什么都没有发生，新启动的 Activity 没有启动，上一个 Activity 的生命周期也不会发生变化。</p>
<h3 id=解决办法>解决办法</h3>
<p>梳理清楚了流程解决方案就很简单了，很多地方都有能打破这种奇葩 case 的可能，让 <code>startActivityInner</code> 正常进行后面的逻辑处理，仅列举几个简单的方法，根据自身的业务自行处理：</p>
<ul>
<li>
<p>使得 <code>getReusableTask</code> 中 <code>putIntoExistingTask</code> 为 <code>false</code>：比如设置第二次启动 A_Activity 的 Flag 为 <code>FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_MULTIPLE_TASK</code>；或者如果在允许的条件下（比如不是复现流程时的 Service 中启动），直接去掉 <code>FLAG_ACTIVITY_NEW_TASK</code> 即可。</p>
</li>
<li>
<p>只要让 <code>complyActivityFlags</code> 能进入 <code>mAddingToTask</code> 为 <code>true</code> 的 case ，这里分支非常多，所以方案也更多：比如设置第二次启动 A_Activity 的 Flag 为 <code>FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK</code>；或者就像前面分析 <code>finish</code> 的影响，注意栈的情况不要使得启动栈的 Activity 和待启动的 Activity 相同。</p>
</li>
</ul>
<h2 id=再现异常>再现异常</h2>
<h3 id=复现流程-1>复现流程</h3>
<p>根据我们的业务需求，我们选择的方案如下：</p>
<ol>
<li>
<p>Service 附加 <code>FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK</code> 启动 A_Activity，A_Activity 的 launchMode 为 <code>singleInstance</code>：</p>
<pre><code class=language-kotlin>startActivity(Intent(this, AActivity::class.java).apply { addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK) })
</code></pre>
</li>
<li>
<p>A_Activity 启动 B_Activity：</p>
<pre><code class=language-kotlin>startActivity(Intent(this, BActivity::class.java))
</code></pre>
</li>
<li>
<p>同步骤 1 启动 A_Activity。</p>
</li>
<li>
<p>同步骤 2 启动 B_Activity。</p>
</li>
</ol>
<p>此时会出现 B_Activity 没有新建实例，而是会回调 <code>onRestart</code> 启动了第一次创建的 B_Activity。</p>
<h3 id=源码追踪-1>源码追踪</h3>
<p>根据上面的分析我们轻车熟路了，这又是某些 case 下没有创建 B_Activity 的实例而直接回调的 <code>onResume</code> 导致的。但是之前无法启动 A_Activity 是因为添加了 <code>FLAG_ACTIVITY_NEW_TASK</code>，然而现在启动 B_Activity 可什么 Flag 都没加，就是最简单的 <code>startActivity</code>，B_Activity 的 launchMode 也是最基本的 <code>standard</code>。</p>
<p>其实原因依然隐藏在源码中，<code>startActivityInner</code> 会调用 <code>computeLaunchingTaskFlags</code> 来计算启动时的 Flag：</p>
<pre><code class=language-java>// com.android.server.wm.ActivityStarter
private void computeLaunchingTaskFlags() {
    ……
    if (mInTask == null) {
        if (mSourceRecord == null) {
            if ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == 0 &amp;&amp; mInTask == null) {
                Slog.w(TAG, &quot;startActivity called from non-Activity context; forcing &quot; +
                        &quot;Intent.FLAG_ACTIVITY_NEW_TASK for: &quot; + mIntent);
                mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;
            }
        } else if (mSourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) {
            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;
        } else if (isLaunchModeOneOf(LAUNCH_SINGLE_INSTANCE, LAUNCH_SINGLE_TASK)) {
            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;
        }
    }
}
</code></pre>
<p>在不指定启动栈时，三种情况下系统会默认给 Flag 加上 <code>FLAG_ACTIVITY_NEW_TASK</code>:</p>
<ol>
<li>没有源 Activity（比如 A 启动 B，则 A 为源 Activity）</li>
<li>源 Activity 的 launchMode 是 <code>singleInstance</code></li>
<li>待启动 Activity 的 launchMode 是 <code>singleInstance</code> 或 <code>singleTask</code></li>
</ol>
<p>原因就显而易见了，我们的 A_Activity 的 launchMode 是 <code>singleInstance</code>，所以系统给 Flag 加上了 <code>FLAG_ACTIVITY_NEW_TASK</code>，于是又回到了之前分析的场景中。</p>
<h3 id=解决办法-1>解决办法</h3>
<p>解决办法上一个场景中也给出了，启动 B_Activity 时加上 <code>FLAG_ACTIVITY_MULTIPLE_TASK</code>即可：</p>
<pre><code class=language-kotlin>startActivity(
    Intent(this, BActivity::class.java)
        .apply { addFlags(Intent.FLAG_ACTIVITY_MULTIPLE_TASK) })
</code></pre>
<h2 id=总结>总结</h2>
<p>Activity 启动这块是非常复杂的，影响的因素也非常多，上面的两个场景还是属于比较简单的，仅仅是 <code>FLAG_ACTIVITY_NEW_TASK</code> 就造成了这么多的问题，而且看起都非常诡异难以排查，更不用说各种启动模式和 Flag 叠加时可能会遇到更多的坑点，不过一旦遇到了这些神坑，其实深入源码去研究有时候反而能更快得到结论。</p>
</div>
<div class=my-4>
<a href=/tags/%E6%BA%90%E7%A0%81/ class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#源码</a>
</div>
<div class="flex flex-col md:flex-row md:justify-between -mx-2 mt-4 px-2 pt-4 border-t">
<div>
<span class="block font-bold"></span>
<a href=/posts/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E6%95%88%E5%90%8C%E6%AD%A5git%E4%BB%93%E5%BA%93%E5%88%B0github/ class=block>使用阿里云效同步 Git 仓库到 Github</a>
</div>
<div class="md:text-right mt-4 md:mt-0">
<span class="block font-bold"></span>
<a href=/posts/%E9%81%B5%E5%BE%AA-google-%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97%E7%9A%84-retrofit-+-coroutine-%E5%B0%81%E8%A3%85/ class=block>遵循 Google 应用指南的 Retrofit + Coroutine 封装</a>
</div>
</div>
</div>
<div class=col-span-2>
<div class="sticky top-16 z-10 hidden lg:block px-6 py-4 bg-primary-bg">
<span class="text-lg font-semibold"></span>
</div>
<div class="sticky-toc hidden lg:block px-6 pb-6">
<nav id=TableOfContents>
<ul>
<li><a href=#引言>引言</a>
<ul>
<li><a href=#基本-launchmode-行为模式>基本 LaunchMode 行为模式</a></li>
<li><a href=#service-启动-activity>Service 启动 Activity</a></li>
</ul>
</li>
<li><a href=#无法启动的-standard-activity>无法启动的 <code>standard</code> Activity</a>
<ul>
<li><a href=#复现流程>复现流程</a></li>
<li><a href=#原因推测>原因推测</a></li>
<li><a href=#源码追踪>源码追踪</a>
<ul>
<li><a href=#startactivityinner>startActivityInner</a></li>
<li><a href=#getreusabletask>getReusableTask</a></li>
<li><a href=#recycletask>recycleTask</a></li>
<li><a href=#complyactivityflags>complyActivityFlags</a></li>
<li><a href=#resumetopactivityinnerlocked>resumeTopActivityInnerLocked</a></li>
</ul>
</li>
<li><a href=#原因总结>原因总结</a></li>
<li><a href=#解决办法>解决办法</a></li>
</ul>
</li>
<li><a href=#再现异常>再现异常</a>
<ul>
<li><a href=#复现流程-1>复现流程</a></li>
<li><a href=#源码追踪-1>源码追踪</a></li>
<li><a href=#解决办法-1>解决办法</a></li>
</ul>
</li>
<li><a href=#总结>总结</a></li>
</ul>
</nav>
</div>
<script>window.addEventListener('DOMContentLoaded',()=>{enableStickyToc()})</script>
</div>
</div>
<script>document.addEventListener('DOMContentLoaded',()=>{hljs.initHighlightingOnLoad()})</script>
</div>
</div>
</main>
<footer class=pl-scrollbar>
<div class="w-full max-w-screen-xl mx-auto"><div class="flex flex-col justify-center p-6">
<a class=mx-auto href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank>
<img src=https://static.fori.fun/blog/posts/img/cc_by_nc_sa.svg alt="CC BY-NC-SA 4.0" title="本博客均以《署名-非商业性使用-相同方式共享 4.0 国际》协议发布">
</a>
<p class="mx-auto pt-2 text-sm text-tertiary-text">&copy; 2022 <a href=https://blog.io01.xyz/>IO01</a>
&#183; Powered by the <a href=https://github.com/wangchucheng/hugo-eureka class=hover:text-eureka>Eureka</a> theme for <a href=https://gohugo.io class=hover:text-eureka>Hugo</a>
</p>
</div></div>
</footer>
</body>
</html>