<!doctype html><html lang><meta charset=utf-8><meta name=viewport content="width=device-width"><title>有趣的算法 - 布隆过滤器 | IO01 Blog</title><meta name=generator content="Hugo Eureka 0.8.0"><link rel=stylesheet href=/css/eureka.min.css><script defer src=/js/eureka.min.js></script>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap" as=style onload='this.onload=null,this.rel="stylesheet"'><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/solarized-light.min.css media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/languages/dart.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js integrity="sha256-uNYoXefWRqv+PsIF/OflNmwtKM4lStn9yrz2gVl6ymo=" crossorigin></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><script defer src=https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js integrity="sha256-Zmpaaj+GXFsPF5WdPArSrnW3b30dovldeKsW00xBVwE=" crossorigin></script>
<link rel=icon type=image/png sizes=32x32 href=/images/favicon_huc32cac3e9dc2dba9d765d255923cde91_27863_32x32_fill_box_center_3.png><link rel=apple-touch-icon sizes=180x180 href=/images/favicon_huc32cac3e9dc2dba9d765d255923cde91_27863_180x180_fill_box_center_3.png><meta name=description content="引言
现在假设一个需求：设计一个 url 黑名单系统，需求是 1 亿个 url 黑名单，每个 url 平均长度 30 字节，判断当前的 url 是否在黑名单中。
我们最先想到的可能时 HashSet，如果少量的 url，HashSet 有着 O(1) 的查询效率是首选的方案。但是面对 1 亿个 url，单单存储 value 就需要 2861MB 内存，显然不可取。而如果放到硬盘上进行数据库查询，面对近 3GB 的数据库，每次匹配都要查询的话，IO 操作本身就是瓶颈。
所以这时候引入了布隆过滤器。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":2,"name":"有趣的算法 - 布隆过滤器","item":"/posts/27fg/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/27fg/"},"headline":"有趣的算法 - 布隆过滤器 | IO01 Blog","datePublished":"2019-10-30T00:00:00+00:00","dateModified":"2019-10-30T00:00:00+00:00","wordCount":1489,"publisher":{"@type":"Person","name":"C. Wang","logo":{"@type":"ImageObject","url":"/images/favicon.png"}},"description":"\u003ch2 id=\u0022引言\u0022\u003e引言\u003c\/h2\u003e\n\u003cp\u003e现在假设一个需求：设计一个 url 黑名单系统，需求是 1 亿个 url 黑名单，每个 url 平均长度 30 字节，判断当前的 url 是否在黑名单中。\u003c\/p\u003e\n\u003cp\u003e我们最先想到的可能时 HashSet，如果少量的 url，HashSet 有着 O(1) 的查询效率是首选的方案。但是面对 1 亿个 url，单单存储 value 就需要 2861MB 内存，显然不可取。而如果放到硬盘上进行数据库查询，面对近 3GB 的数据库，每次匹配都要查询的话，IO 操作本身就是瓶颈。\u003c\/p\u003e\n\u003cp\u003e所以这时候引入了布隆过滤器。\u003c\/p\u003e"}</script><meta property="og:title" content="有趣的算法 - 布隆过滤器 | IO01 Blog"><meta property="og:type" content="article"><meta property="og:image" content="/images/favicon.png"><meta property="og:url" content="/posts/27fg/"><meta property="og:description" content="引言
现在假设一个需求：设计一个 url 黑名单系统，需求是 1 亿个 url 黑名单，每个 url 平均长度 30 字节，判断当前的 url 是否在黑名单中。
我们最先想到的可能时 HashSet，如果少量的 url，HashSet 有着 O(1) 的查询效率是首选的方案。但是面对 1 亿个 url，单单存储 value 就需要 2861MB 内存，显然不可取。而如果放到硬盘上进行数据库查询，面对近 3GB 的数据库，每次匹配都要查询的话，IO 操作本身就是瓶颈。
所以这时候引入了布隆过滤器。"><meta property="og:site_name" content="IO01 Blog"><meta property="article:published_time" content="2019-10-30T00:00:00+00:00"><meta property="article:modified_time" content="2019-10-30T00:00:00+00:00"><meta property="article:section" content="posts"><meta property="article:tag" content="杂项"><body class="flex flex-col min-h-screen"><header class="fixed flex items-center w-full min-h-16 pl-scrollbar z-50 bg-secondary-bg shadow-sm"><div class="w-full max-w-screen-xl mx-auto"><script>let storageColorScheme=localStorage.getItem("lightDarkMode");((storageColorScheme=="Auto"||storageColorScheme==null)&&window.matchMedia("(prefers-color-scheme: dark)").matches||storageColorScheme=="Dark")&&document.getElementsByTagName("html")[0].classList.add("dark")</script><nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0"><a href=/ class="mr-6 text-primary-text text-xl font-bold">IO01 Blog</a>
<button id=navbar-btn class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
<i class="fas fa-bars"></i></button><div id=target class="hidden block md:flex md:flex-grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20"><div class="md:flex md:h-16 text-sm md:flex-grow pb-4 md:pb-0 border-b md:border-b-0"></div><div class=flex><div class="relative pt-4 md:pt-0"><div class="cursor-pointer hover:text-eureka" id=lightDarkMode><i class="fas fa-adjust"></i></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id=is-open></div><div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40" id=lightDarkOptions><span class="px-4 py-1 hover:text-eureka" name=Light></span>
<span class="px-4 py-1 hover:text-eureka" name=Dark></span>
<span class="px-4 py-1 hover:text-eureka" name=Auto></span></div></div></div></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id=is-open-mobile></div></nav><script>let element=document.getElementById("lightDarkMode");storageColorScheme==null||storageColorScheme=="Auto"?document.addEventListener("DOMContentLoaded",()=>{window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",switchDarkMode)}):storageColorScheme=="Light"?(element.firstElementChild.classList.remove("fa-adjust"),element.firstElementChild.setAttribute("data-icon","sun"),element.firstElementChild.classList.add("fa-sun")):storageColorScheme=="Dark"&&(element.firstElementChild.classList.remove("fa-adjust"),element.firstElementChild.setAttribute("data-icon","moon"),element.firstElementChild.classList.add("fa-moon")),document.addEventListener("DOMContentLoaded",()=>{getcolorscheme(),switchBurger()})</script></div></header><main class="flex-grow pt-16"><div class=pl-scrollbar><div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto"><div class="grid grid-cols-2 lg:grid-cols-8 gap-4 lg:pt-12"><div class="col-span-2 lg:col-span-6 bg-secondary-bg rounded px-6 py-8"><h1 class="font-bold text-3xl text-primary-text">有趣的算法 - 布隆过滤器</h1><div class="flex flex-wrap flex-row items-center mt-2 text-tertiary-text"><div class="mr-6 my-2"><i class="fas fa-calendar mr-1"></i>
<span>2019-10-30</span></div></div><div class=content><h2 id=引言>引言</h2><p>现在假设一个需求：设计一个 url 黑名单系统，需求是 1 亿个 url 黑名单，每个 url 平均长度 30 字节，判断当前的 url 是否在黑名单中。</p><p>我们最先想到的可能时 HashSet，如果少量的 url，HashSet 有着 O(1) 的查询效率是首选的方案。但是面对 1 亿个 url，单单存储 value 就需要 2861MB 内存，显然不可取。而如果放到硬盘上进行数据库查询，面对近 3GB 的数据库，每次匹配都要查询的话，IO 操作本身就是瓶颈。</p><p>所以这时候引入了布隆过滤器。</p><h2 id=原理>原理</h2><h3 id=初始化>初始化</h3><p>首先初始化一个长度为 m 的 bit 数组，每一位初始化为 0。</p><h3 id=插入>插入</h3><p>确定 k 个独立的 hash 函数，每个 hash 可以将输入的 url 生成并映射为 1 个 [0,m-1] 的值，每个值作为数组下标，将该位置的值置为 1。</p><h3 id=查询>查询</h3><p>同插入部分，将输入的 url 用插入时确定的 k 个 hash 函数生成 k 个数组下标，逐个检测每个下标对应的位置的值，如果有一个不为 1 则确定不在集合中，如果全部为 1，则有可能在集合中。</p><h3 id=误判>误判</h3><p>误判来自两方面：</p><ol><li>由于 hash 函数是有碰撞几率的，虽然多个 hash 会大大降低这种几率，但是仍然有几率两个完全不同的 url 通过 hash 后得到的 k 个值完全相同。</li><li>多次插入以后不同的插入组合可能与某个未插入值经过 hash 后的值相同，我们极端化思考：当数组被 1 填充满后，任何输入都会被判断为存在。</li></ol><p>所以布隆过滤器判断不存在的一定不存在，判断存在的可能有误判率。根据误判我们可以做一些提高准确性的工作：当判断存在时进行一次数据库查询，对误判建立白名单系统。当然，如果本身可接受极低的误判率，那通过尽可能降低误判率后忽略误判。</p><h3 id=公式>公式</h3><p>设过滤器数组的长度为 m，插入的值的个数为 n，hash 函数的个数为 k，误报率为ε。</p><ul><li><p>给定插入个数和误报率可得过滤器的长度为：$m=-{\frac {n\ln \varepsilon }{(\ln 2)^{2}}}$</p></li><li><p>给定 m 和 n 时最优 hash 函数个数为：$k={\frac {m}{n}}\ln 2$，给定误报率时 hash 函数个数为：$k=-\log _{2}\varepsilon $</p></li><li><p>给定 m 和 n 时误报率为：$\varepsilon \leq \left(1-e^{-{\frac {k(n+0.5)}{m-1}}}\right)^{k}$，当 m 比较大时，可以近似为：$\varepsilon \approx \left(1-e^{-{\frac {kn}{m}}}\right)^{k}$</p></li></ul><h3 id=图示示例>图示示例</h3><ol><li><p>设置一个 [0,14] 长度为 15 的数组，使用两个 hash 函数：<code>Fnv</code> 和 <code>Murmur</code>:</p><p><img src=https://static.fori.fun/blog/posts/img/bloom_filter_init.png alt=初始化></p></li><li><p>插入 1，fnv(1)=7，murmur(1)=2：</p><p><img src=https://static.fori.fun/blog/posts/img/bloom_filter_add_1.png alt=初始化></p></li><li><p>插入 3，fnv(3)=9，murmur(3)=14：</p><p><img src=https://static.fori.fun/blog/posts/img/bloom_filter_add_3.png alt=初始化></p></li><li><p>查询 2，fnv(2)=8，murmur(2)=9，<code>Murmur</code>命中但<code>Fnv</code>未命中，所以肯定不存在 2：</p><p><img src=https://static.fori.fun/blog/posts/img/bloom_filter_find_2.png alt=初始化></p></li><li><p>查询 14，fnv(14)=2，murmur(14)=14，两个 hash 函数均命中，所以可能存在 14：</p><p><img src=https://static.fori.fun/blog/posts/img/bloom_filter_find_14.png alt=初始化></p></li></ol><p>注：此处使用两个 hash 函数得出 hash 值后取余映射回了 [0,14] 区间，并非直接所得 hash 值。</p><h2 id=进阶>进阶</h2><p><strong>注：</strong> <em>仅供扩展了解，本人并未真正去推导</em></p><p>根据原理可知，该算法的时间复杂度为 O(k)，也就是性能瓶颈为 k 个独立的 hash 函数。当误报率小于 0.01%时，需要 13 个 hash 函数，这在频繁查询中也是一个很大的性能压力。<a href=https://static.fori.fun/blog/posts/file/bloom_filters_in_probabilistic_verification.pdf>《Bloom Filters in Probabilistic Verification》</a> 这篇论文很好的解决了这个问题，将 k 个不同的 hash 函数转换成了 2 个 hash 函数的简单运算，其公式为：$g_{i}(x)=h_{1}(x)+ih_{2}(x)+i^{2}\bmod m,i\in \left(0,k \right)$</p><p>根据公式我们可以得到第 i 个 hash 函数的值而不需要真的准备 k 个 hash 函数去计算。这样只需要 2 个 hash 函数即可完成布隆过滤器。另一篇哈佛的论文：<a href=https://static.fori.fun/blog/posts/file/building_a_better_bloom_filter.pdf>《Less Hashing, Same Performance: Building a Better Bloom Filter》</a> 对该方法有效性进行了证明。</p><h2 id=应用>应用</h2><p>我们只需要利用布隆过滤器真阴性性质就已经可以在 IO 查询前加入一层过滤系统来大大降低 IO 操作，如果可以容忍或者通过其他方式避免低概率的假阳性，那么可以用到更加广泛的方面。</p><p>业界常用的案例是垃圾邮件的过滤系统，爬虫的 url 去重系统。</p><p>实际上各种 k-v 储存都可以并且已经应用布隆过滤器来减少 IO 操作，比如 Leveldb，Hbase。</p></div><div class=my-4><a href=/tags/%E6%9D%82%E9%A1%B9/ class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#杂项</a></div><div class="flex flex-col md:flex-row md:justify-between -mx-2 mt-4 px-2 pt-4 border-t"><div><span class="block font-bold"></span>
<a href=/posts/57fb/ class=block>从阿里规约谈起 - 包装类的值比较注意事项</a></div><div class="md:text-right mt-4 md:mt-0"><span class="block font-bold"></span>
<a href=/posts/23af/ class=block>从阿里规约谈起 - Arrays.asList 三坑</a></div></div></div><div class=col-span-2><div class="sticky top-16 z-10 hidden lg:block px-6 py-4 bg-primary-bg"><span class="text-lg font-semibold"></span></div><div class="sticky-toc hidden lg:block px-6 pb-6"><nav id=TableOfContents><ul><li><a href=#引言>引言</a></li><li><a href=#原理>原理</a><ul><li><a href=#初始化>初始化</a></li><li><a href=#插入>插入</a></li><li><a href=#查询>查询</a></li><li><a href=#误判>误判</a></li><li><a href=#公式>公式</a></li><li><a href=#图示示例>图示示例</a></li></ul></li><li><a href=#进阶>进阶</a></li><li><a href=#应用>应用</a></li></ul></nav></div><script>window.addEventListener("DOMContentLoaded",()=>{enableStickyToc()})</script></div></div><script>document.addEventListener("DOMContentLoaded",()=>{hljs.initHighlightingOnLoad()})</script></div></div></main><footer class=pl-scrollbar><div class="w-full max-w-screen-xl mx-auto"><div class="flex flex-col justify-center p-6"><a class=mx-auto href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank><img src=https://static.fori.fun/blog/posts/img/cc_by_nc_sa.svg alt="CC BY-NC-SA 4.0" title="本博客均以《署名-非商业性使用-相同方式共享 4.0 国际》协议发布"></a><p class="mx-auto pt-2 text-sm text-tertiary-text">&copy; 2022 <a href=https://blog.io01.xyz/>IO01</a>
&#183; Powered by the <a href=https://github.com/wangchucheng/hugo-eureka class=hover:text-eureka>Eureka</a> theme for <a href=https://gohugo.io class=hover:text-eureka>Hugo</a></p></div></div></footer></body></html>